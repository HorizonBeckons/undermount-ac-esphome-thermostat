# Originally written by https://github.com/anthonysecco for Undermount AC v3
# Special thanks to Mike Goubeaux (Smarty Van) for the base code
# 
# Adapted by Chris Herman (HorizonBeckons) for Undermount AC v2 systems with safety and compatibility enhancements:
# - Ported and tested for v2 hardware compatibility
# - Added comprehensive compressor protection system
# - Enhanced PID control with safety features
# - Implemented diagnostic monitoring and emergency handling
# - Testing and validation on v2 hardware
#
# Version 0.4.4 Updates:
# - Fixed blower fan speed control (uses integer speeds 1-100 for proper operation)
# - Enhanced cooling request handling with pending state management
# - Improved compressor restart protection with automatic recovery
# - Better state transitions between cooling/idle/off modes
# - Fixed issue where compressor wouldn't restart after reaching target temp
#
# Safety Features:
# - 2-minute compressor short cycle protection (prevents damage from rapid cycling)
# - 2-minute restart delay after compressor stops
# - Emergency blower activation if compressor runs without fan
# - Manual safety override switch for emergency situations
# - Automatic recovery from protection states
#
# - Auto Mode High Speed Compressor Functionality remains untested
#
# IMPORTANT: Wire colors differ between v2 and v3 systems!
# GPIO pin assignments remain the same, only wire colors change.
# To be used with Undermount AC ESP Home Thermostat and v2 System
# 
# V2 Connector Matrix:
# GPIO 7  - Output 1 - Blower Speed (Red Wire)
# GPIO 9  - Output 2 - Blower Power On/Off (Yellow Wire) 
# GPIO 8  - Output 3 - Compressor Power (Blue Wire)
# GPIO 10 - Output 4 - High-Speed Compressor (Orange Wire)
# Output 5 - Unused
# Output 6 - Unused
# POS - DC+ IN  (Red/White Wire)
# NEG - DC- IN (Black Wire)
#
# V3 Wire Colors (for reference):
# Output 1 - White Wire
# Output 2 - Brown Wire
# Output 3 - Blue Wire (same)
# Output 4 - Green Wire

# Substitutions
################################################################################
substitutions:
  device_name: undermount-ac
  friendly_name: "Undermount AC v2"

  ### PID Tune Control ###
  kp: '0.2' # Proportional
  ki: '0.000334' # Integral
  kd: '0.0' # Derivative
  integral_clamp_factor: '1.5' # Dynamic Integral clamp to prevent windup

# Globals
################################################################################
globals:
  # PID Control Globals
  - id: integral
    type: float
    initial_value: '0.0'
  - id: previous_error
    type: float
    initial_value: '0.0'
  - id: last_time
    type: uint32_t
    initial_value: '0'

  # Compressor Protection Globals
  - id: compressor_start_time
    type: uint32_t
    initial_value: '0'
  - id: compressor_stop_time
    type: uint32_t
    initial_value: '0'
  - id: compressor_running
    type: bool
    initial_value: 'false'
  - id: pending_state_change
    type: int
    initial_value: '0'  # 0=none, 1=idle, 2=off, 3=cooling

  # High-speed Compressor Globals
  - id: high_speed_threshold_met_time
    type: uint32_t
    initial_value: '0'
  - id: high_speed_threshold_unmet_time
    type: uint32_t
    initial_value: '0'
  - id: high_speed_threshold_met
    type: bool
    initial_value: 'false'
  - id: high_speed_active
    type: bool
    initial_value: 'false'

  # Blower Ramp Globals
  - id: current_blower_speed
    type: float
    initial_value: '0'
  - id: target_blower_speed
    type: float
    initial_value: '0'
  - id: ramp_blower
    type: bool
    initial_value: 'false'

# Board Configuration
################################################################################
esphome:
  name: ${device_name}
  friendly_name: ${friendly_name}
  on_boot:
    priority: -10
    then:
      - lambda: |-
          // Initialize all protection timers
          id(compressor_stop_time) = millis();
          id(compressor_running) = false;
          id(pending_state_change) = 0;
          
          // Initialize PID
          id(integral) = 0.0;
          id(previous_error) = 0.0;
          id(last_time) = 0;
          
          // Initialize blower
          id(current_blower_speed) = 0;
          id(target_blower_speed) = 0;
          id(ramp_blower) = false;

  project:
    name: anthonysecco.undermount-ac-v2-thermostat
    version: "0.4.4"

esp32:
  board: esp32-s3-devkitc-1
  framework:
    type: arduino

# Connectivity
################################################################################
wifi:
  ap:
    ssid: "${friendly_name} Fallback AP"
    password: "12345678"

captive_portal:

# Core Services
################################################################################
logger:
  level: DEBUG  # Set to DEBUG for troubleshooting

api:

ota:
  - platform: esphome

# LEDs
################################################################################
light:
  - platform: status_led
    name: "status led"
    internal: true
    output: statusoutput
  
  - platform: neopixelbus
    variant: WS2812
    pin: 48
    num_leds: 1
    name: "Status LED RGB"
    internal: True
    restore_mode: ALWAYS_OFF
    id: statusledlight
    icon: "mdi:led-outline"
    effects:
      - strobe:
          name: "Not Connected"
          colors:
            - state: True
              brightness: 50%
              red: 100%
              green: 0%
              blue: 0%
              duration: 1s
            - state: False
              duration: 1s
      - pulse:
          name: "Pulse"
          update_interval: 2s
          min_brightness: 40%
          max_brightness: 60%
      - pulse:
          name: "Pulse Fast"
          transition_length: 0.25s
          update_interval: 0.5s
          min_brightness: 40%
          max_brightness: 60%

# Sensors
################################################################################
i2c:
  sda: GPIO21
  scl: GPIO14
  scan: true
  id: bus_a

sensor:
  - platform: sht3xd
    i2c_id: bus_a
    id: onboard_sht30
    humidity:
      name: "UndermountAC v2 Humidity"
      id: onboard_humidity
      accuracy_decimals: 0
      
    temperature:
      name: "UndermountAC v2 Temperature"
      id: onboard_temperature
      filters:
        - median:
            window_size: 3
            send_every: 1
            send_first_at: 1
        - delta: 0.1
        - sliding_window_moving_average:
            window_size: 3  # Reduced for faster response
            send_every: 1
        - lambda: return round(x * 10.0) / 10.0;
      accuracy_decimals: 1
      unit_of_measurement: "°C"
    update_interval: 15s

  - platform: template
    id: blower_speed_called
    name: "Output 1 (Blower Speed)"
    unit_of_measurement: "%"
    accuracy_decimals: 0
    entity_category: diagnostic
    icon: mdi:fan
    disabled_by_default: true

  - platform: template
    id: compressor_protection_time_remaining
    name: "Compressor Protection Time Remaining"
    unit_of_measurement: "s"
    accuracy_decimals: 1
    entity_category: diagnostic
    icon: "mdi:timer-sand"
    lambda: |-
      uint32_t now = millis();
      
      if (id(compressor_running)) {
        // Short cycle protection - must run for 2 minutes
        uint32_t elapsed = now - id(compressor_start_time);
        if (elapsed < 120000) {
          return (120000 - elapsed) / 1000.0;
        }
      } else {
        // Restart protection - must wait 2 minutes
        uint32_t elapsed = now - id(compressor_stop_time);
        if (elapsed < 120000) {
          return (120000 - elapsed) / 1000.0;
        }
      }
      return 0.0;

binary_sensor:
  - platform: template
    name: "Compressor Protection Active"
    id: compressor_protection_active
    device_class: "safety"
    entity_category: "diagnostic"
    icon: "mdi:shield-check"
    lambda: |-
      uint32_t now = millis();
      
      if (id(compressor_running)) {
        // Short cycle protection
        return (now - id(compressor_start_time)) < 120000;
      } else {
        // Restart protection
        return (now - id(compressor_stop_time)) < 120000;
      }

  - platform: template
    name: "Output 2 (Blower Power)"
    id: blower_power_called
    device_class: "running"
    entity_category: "diagnostic"
    icon: "mdi:toggle-switch"
    lambda: |-
      return id(blower_power).is_enabled();
    disabled_by_default: true

  - platform: template
    name: "Output 3 (Compressor Power)"
    id: compressor_power_called
    device_class: "running"
    entity_category: "diagnostic"
    icon: "mdi:toggle-switch"
    lambda: |-
      return id(compressor_power).state;
    disabled_by_default: true

  - platform: template
    name: "High-Speed Status"
    id: high_speed_compressor_called
    device_class: "running"
    entity_category: "diagnostic"
    icon: "mdi:speedometer"
    lambda: |-
      return id(compressor_speed_high).state;

# Outputs
################################################################################
output:
  - platform: template
    id: statusoutput
    type: binary
    write_action:
      - if:
          condition:
             lambda: return state > 0;
          then:
            - light.turn_on: 
                id: statusledlight
                effect: "Not Connected"
          else:
            - light.turn_off: 
                id: statusledlight

  - platform: template
    id: blower_pwm_filter
    type: float
    min_power: 0.00  # Keep at 0.00 - no static minimum
    max_power: 0.97  # Max 97% as per requirements
    power_supply: blower_power
    write_action:
      - lambda: |-
          ESP_LOGD("BlowerPWM", "=== PWM FILTER ENTRY ===");
          ESP_LOGD("BlowerPWM", "Input state: %.3f", state);
          
          // Handle true zero case
          if (state <= 0.001) {  // Small threshold to handle floating point
              id(blower_pwm).set_level(0.0);
              id(blower_speed_called).publish_state(0.0);
              ESP_LOGD("Blower", "Speed: 0%% (true zero)");
              return;
          }

          // Map input percentage to duty cycle
          float duty_cycle;
          
          if (state <= 0.20) {
              duty_cycle = 0.20;  // Hardware minimum operating speed
          } else {
              // Linear mapping from 20% to 96% duty cycle for 20-97% input
              duty_cycle = 0.20 + (state - 0.20) * (0.96 - 0.20) / (0.97 - 0.20);
          }
          
          // Ensure bounds
          duty_cycle = fmax(0.20, fmin(0.96, duty_cycle));
          
          ESP_LOGD("BlowerPWM", "Mapped: input=%.1f%% -> duty=%.3f", state * 100, duty_cycle);
          
          // Always update PWM when non-zero
          id(blower_pwm).set_level(duty_cycle);
          id(blower_speed_called).publish_state(duty_cycle * 100);
          ESP_LOGI("Blower", "PWM Updated: Speed %.1f%%, Duty %.3f", duty_cycle * 100, duty_cycle);

  - platform: ledc
    pin: 7          # Output 1 - Blower Speed (Red Wire on v2, White Wire on v3)
    id: blower_pwm
    frequency: 240 hz
    zero_means_zero: true

power_supply: 
  - id: blower_power
    pin: 
      number: 9     # Output 2 - Blower Power (Yellow Wire on v2, Brown Wire on v3)
      inverted: true
    enable_time: 20ms   # Small delay for power stabilization
    keep_on_time: 2s    # Keep power on for 2s after last use

fan:
  - platform: speed
    name: "Blower"
    output: blower_pwm_filter
    id: blower_fan
    speed_count: 100
    disabled_by_default: true

number:
  - platform: template
    id: cooling_min_power
    name: "Minimum Cooling Blower Speed"
    optimistic: true
    min_value: 40
    max_value: 60
    step: 1
    unit_of_measurement: "%"
    icon: "mdi:fan"
    entity_category: "config"
    restore_value: true
    initial_value: 40

switch:  
  - platform: gpio
    id: compressor_power
    pin:
      number: 8     # Output 3 - Compressor Power (Blue Wire on both v2 and v3)
      inverted: true
    restore_mode: ALWAYS_OFF
    internal: true

  - platform: gpio
    id: compressor_speed_high
    pin:
      number: 10    # Output 4 - High-Speed Compressor (Orange Wire on v2, Green Wire on v3)
      inverted: true
    restore_mode: ALWAYS_OFF
    internal: true

  - platform: template
    name: "Enable High-speed Compressor"
    id: enable_high_speed
    restore_mode: RESTORE_DEFAULT_OFF
    optimistic: true

  - platform: template
    name: "High-Speed Test Switch"
    id: high_speed_test
    restore_mode: ALWAYS_OFF
    optimistic: true
    on_turn_on:
      - if:
          condition:
            lambda: return id(compressor_power).state;
          then:
            - switch.turn_on: compressor_speed_high
            - lambda: |-
                ESP_LOGI("Test", "High-speed test activated");
          else:
            - lambda: |-
                ESP_LOGW("Test", "Cannot activate high-speed - compressor not running");
    on_turn_off:
      - switch.turn_off: compressor_speed_high
      - lambda: |-
          ESP_LOGI("Test", "High-speed test deactivated");

  # Compressor Safety Override
  - platform: template
    name: "Compressor Safety Override"
    id: compressor_safety_override
    restore_mode: ALWAYS_OFF
    optimistic: true
    entity_category: "config"
    icon: "mdi:shield-off"
    on_turn_on:
      - lambda: |-
          ESP_LOGW("Safety", "COMPRESSOR SAFETY OVERRIDE ACTIVATED!");
          ESP_LOGW("Safety", "All compressor protection timers have been reset");
          // Reset all protection timers
          id(compressor_stop_time) = 0;
          id(compressor_start_time) = 0;
          id(compressor_running) = false;
          id(pending_state_change) = 0;
          ESP_LOGI("Safety", "Cleared pending state and protection timers");
      - delay: 1s
      - switch.turn_off: compressor_safety_override  # Auto turn off after use
      - lambda: |-
          ESP_LOGI("Safety", "Safety override completed - normal protection restored");

# Climate
################################################################################
climate:
  - platform: thermostat
    name: "Air Conditioner v2"
    id: undermount_thermostat
    sensor: onboard_temperature
    visual:
      temperature_step: 1.0
      min_temperature: 65 °F
      max_temperature: 95 °F

    min_cooling_off_time: 2min
    min_cooling_run_time: 2min
    min_idle_time: 2min
    min_fanning_off_time: 2min
    min_fanning_run_time: 2min
    cool_deadband: 0.5 °C
    cool_overrun: 1.0 °C

    fan_only_action:
      - script.execute: handle_fan_only_request

    cool_action:
      - script.execute: handle_cooling_request
      
    idle_action:
      - script.execute: handle_idle_request

    off_mode:
      - script.execute: handle_off_request

    on_boot_restore_from: memory
    default_preset: Standby
    preset:
      - name: Standby
        default_target_temperature_high: 75 °F
        fan_mode: AUTO
        mode: "OFF"
      - name: Home
        default_target_temperature_high: 75 °F
        fan_mode: AUTO
        mode: COOL
      - name: Sleep
        default_target_temperature_high: 72 °F
        fan_mode: AUTO
        mode: COOL
      - name: Away
        default_target_temperature_high: 90 °F
        fan_mode: AUTO
        mode: COOL
    
    min_fan_mode_switching_time: 1s
    fan_only_cooling: true

    fan_mode_low_action:
      - script.execute:
          id: set_manual_fan_speed
          speed: 25

    fan_mode_medium_action:
      - script.execute:
          id: set_manual_fan_speed
          speed: 50

    fan_mode_high_action:
      - script.execute:
          id: set_manual_fan_speed
          speed: 100

    fan_mode_auto_action:
      - lambda: |-
          // Reset PID state completely
          id(integral) = 0.0;
          id(previous_error) = 0.0;
          id(last_time) = 0;  // Important: reset timing
          ESP_LOGI("Climate", "Fan Mode: AUTO - PID reset");
      - script.execute: climate_fan_auto_pid

    on_state:
      - script.execute: update_compressor_control
      - script.execute: status_light_update

# Scripts
################################################################################
script:
  - id: handle_fan_only_request
    then:
      - lambda: |-
          // Fan-only mode should NEVER be blocked by compressor protection
          ESP_LOGI("Mode", "Fan-only mode requested");
          
          // Turn off compressor immediately (no protection needed for fan-only)
          id(compressor_power).turn_off();
          id(compressor_speed_high).turn_off();
          
          // If compressor was running, record stop time for restart protection
          if (id(compressor_running)) {
            id(compressor_running) = false;
            id(compressor_stop_time) = millis();
            ESP_LOGI("Protection", "Compressor stopped for fan-only - restart protection active");
          }
          
          // Reset high-speed state
          id(high_speed_active) = false;
          id(high_speed_threshold_met) = false;
          
          // Clear any pending requests since we're going to fan-only
          if (id(pending_state_change) != 0) {
            ESP_LOGI("State", "Cleared pending state %d for fan-only mode", id(pending_state_change));
            id(pending_state_change) = 0;
          }
          
          // Set initial target and enable ramping
          id(target_blower_speed) = 20;  // Start at minimum for fan-only
          id(ramp_blower) = true;
          
          ESP_LOGI("Mode", "Fan-only: Starting at 20%% minimum speed");
      - delay: 100ms  # Small delay for power supply
      - lambda: |-
          // Start fan if not already running
          if (!id(blower_fan).state) {
            auto call = id(blower_fan).make_call();
            call.set_state(true);
            call.set_speed(1);  // Use speed 1 (1% = 0.01) for speed fans
            call.perform();
            ESP_LOGI("Fan", "Fan started for fan-only mode");
          }
      - script.execute: climate_fan_auto_pid

  - id: handle_cooling_request
    then:
      - lambda: |-
          uint32_t now = millis();
          
          // If compressor is already running, just ensure we're in cooling mode
          if (id(compressor_running)) {
            ESP_LOGI("Cooling", "Already in cooling mode - compressor running");
            
            // Cancel any pending state changes since we want cooling
            id(pending_state_change) = 0;
            
            // Ensure compressor stays on
            if (!id(compressor_power).state) {
              id(compressor_power).turn_on();
            }
            
            // Set cooling fan speed
            float min_speed = id(cooling_min_power).state;
            id(target_blower_speed) = min_speed;
            id(ramp_blower) = true;
            
            // Ensure fan is running
            if (!id(blower_fan).state) {
              auto call = id(blower_fan).make_call();
              call.set_state(true);
              call.set_speed(1);
              call.perform();
            }
            return;
          }
          
          // Compressor not running - check restart protection
          uint32_t time_since_stop = now - id(compressor_stop_time);
          
          if (time_since_stop < 120000 && id(compressor_stop_time) != 0) {
            ESP_LOGW("Protection", "Compressor restart blocked: %.1fs remaining", 
                     (120000 - time_since_stop) / 1000.0);
            ESP_LOGI("Protection", "Use 'Compressor Safety Override' switch to bypass if needed");
            
            // Important: Still run the fan at cooling speed even if compressor can't start
            float min_speed = id(cooling_min_power).state;
            id(target_blower_speed) = min_speed;
            id(ramp_blower) = true;
            
            if (!id(blower_fan).state) {
              auto call = id(blower_fan).make_call();
              call.set_state(true);
              call.set_speed(1);
              call.perform();
            }
            
            // Mark that we want cooling when protection expires
            id(pending_state_change) = 3;  // New state: pending cooling
            return;
          }
          
          // Start compressor - protection allows it
          id(compressor_power).turn_on();
          id(compressor_running) = true;
          id(compressor_start_time) = now;
          id(pending_state_change) = 0;  // Clear any pending changes
          ESP_LOGI("Compressor", "Started - protection active for 2 minutes");
          
          // Set initial target for cooling
          float min_speed = id(cooling_min_power).state;
          id(target_blower_speed) = min_speed;
          id(ramp_blower) = true;
          
          ESP_LOGI("Mode", "Cooling: Starting at %.0f%% minimum speed", min_speed);
      - delay: 10s  # Brief evaporator cooling delay
      - lambda: |-
          // Start fan if not already running
          if (!id(blower_fan).state) {
            auto call = id(blower_fan).make_call();
            call.set_state(true);
            call.set_speed(1);  // Use speed 1 (1% = 0.01) for speed fans
            call.perform();
            ESP_LOGI("Fan", "Fan started for cooling mode");
          }

  - id: handle_idle_request
    then:
      - lambda: |-
          uint32_t now = millis();
          uint32_t time_since_start = now - id(compressor_start_time);
          
          // Clear any pending cooling requests since we're going to idle
          if (id(pending_state_change) == 3) {
            id(pending_state_change) = 0;
            ESP_LOGI("State", "Cancelled pending cooling request for idle");
          }
          
          // Check short cycle protection
          if (time_since_start < 120000 && id(compressor_running)) {
            ESP_LOGW("Protection", "Compressor stop blocked: %.1fs remaining", 
                     (120000 - time_since_start) / 1000.0);
            ESP_LOGI("Protection", "Use 'Compressor Safety Override' switch to bypass if needed");
            id(pending_state_change) = 1;  // Mark idle as pending
            return;
          }
          
          // Execute idle transition
          id(execute_idle_transition).execute();

  - id: handle_off_request
    then:
      - lambda: |-
          uint32_t now = millis();
          uint32_t time_since_start = now - id(compressor_start_time);
          
          // Clear any pending cooling requests since we're turning off
          if (id(pending_state_change) == 3) {
            id(pending_state_change) = 0;
            ESP_LOGI("State", "Cancelled pending cooling request for off");
          }
          
          // Check short cycle protection
          if (time_since_start < 120000 && id(compressor_running)) {
            ESP_LOGW("Protection", "Compressor stop blocked: %.1fs remaining", 
                     (120000 - time_since_start) / 1000.0);
            ESP_LOGI("Protection", "Use 'Compressor Safety Override' switch to bypass if needed");
            id(pending_state_change) = 2;  // Mark off as pending
            return;
          }
          
          // Execute off transition
          id(execute_off_transition).execute();

  - id: execute_idle_transition
    then:
      - lambda: |-
          // Stop compressor and high-speed
          id(compressor_power).turn_off();
          id(compressor_speed_high).turn_off();
          id(compressor_running) = false;
          id(compressor_stop_time) = millis();
          id(pending_state_change) = 0;  // Clear any pending changes
          
          // Reset high-speed state
          id(high_speed_active) = false;
          id(high_speed_threshold_met) = false;
          
          ESP_LOGI("Compressor", "Stopped for idle - restart protection active");
          
          // Set purge speed
          id(target_blower_speed) = 20;
          id(ramp_blower) = true;
      - delay: 30s  # 30-second evaporator purge
      - lambda: |-
          // Stop fan after purge
          id(target_blower_speed) = 0;
          id(current_blower_speed) = 0;
          id(ramp_blower) = false;
      - fan.turn_off: blower_fan

  - id: execute_off_transition
    then:
      - lambda: |-
          // Stop compressor and high-speed
          id(compressor_power).turn_off();
          id(compressor_speed_high).turn_off();
          id(compressor_running) = false;
          id(compressor_stop_time) = millis();
          id(pending_state_change) = 0;  // Clear any pending changes
          
          // Reset high-speed state
          id(high_speed_active) = false;
          id(high_speed_threshold_met) = false;
          
          ESP_LOGI("Compressor", "Stopped for off - restart protection active");
          
          // Set purge speed
          id(target_blower_speed) = 20;
          id(ramp_blower) = true;
      - delay: 30s  # 30-second evaporator purge
      - lambda: |-
          // Complete shutdown
          id(target_blower_speed) = 0;
          id(current_blower_speed) = 0;
          id(ramp_blower) = false;
      - fan.turn_off: blower_fan

  - id: set_manual_fan_speed
    parameters:
      speed: int
    then:
      - lambda: |-
          id(target_blower_speed) = speed;
          id(ramp_blower) = true;
          ESP_LOGI("Fan", "Manual speed: %d%%", speed);
          
          // Ensure fan is on
          if (!id(blower_fan).state) {
            auto call = id(blower_fan).make_call();
            call.set_state(true);
            call.set_speed(1);  // Start at 1%
            call.perform();
          }

  - id: climate_fan_auto_pid
    then:
      - lambda: |-
          ESP_LOGD("PID", "=== PID ENTRY ===");
          ESP_LOGD("PID", "Mode: %d, Fan Mode: %d, Action: %d", 
                   id(undermount_thermostat).mode, 
                   id(undermount_thermostat).fan_mode,
                   id(undermount_thermostat).action);
          
          // Only run PID in appropriate modes
          if (id(undermount_thermostat).fan_mode != CLIMATE_FAN_AUTO ||
              id(undermount_thermostat).mode == CLIMATE_MODE_OFF) {
            ESP_LOGD("PID", "PID not applicable - exiting");
            return;
          }
          
          // Time management
          uint32_t now = millis();
          float dt = (id(last_time) == 0) ? 1.0 : (now - id(last_time)) / 1000.0;
          id(last_time) = now;
          ESP_LOGD("PID", "dt: %.2f seconds", dt);
          
          // PID constants
          const float Kp = ${kp};
          const float Ki = ${ki};
          const float Kd = ${kd};
          
          // Temperature error
          float current_temp = id(undermount_thermostat).current_temperature;
          float target_temp = id(undermount_thermostat).target_temperature;
          float error = current_temp - target_temp;
          ESP_LOGD("PID", "Temps - Current: %.2f°C, Target: %.2f°C, Error: %.2f°C", 
                   current_temp, target_temp, error);
          
          // PID calculation
          float P = Kp * error;
          
          id(integral) += error * dt;
          float integral_limit = fabs(${integral_clamp_factor} * P / Ki);
          id(integral) = fmax(-integral_limit, fmin(id(integral), integral_limit));
          float I = Ki * id(integral);
          
          float derivative = (error - id(previous_error)) / dt;
          float D = Kd * derivative;
          id(previous_error) = error;
          
          ESP_LOGD("PID", "Components - P: %.3f, I: %.3f, D: %.3f", P, I, D);
          
          // Calculate output (0-1)
          float output = fmax(0.0, fmin(1.0, P + I + D));
          ESP_LOGD("PID", "Raw PID output: %.3f", output);
          
          // Apply minimum based on mode
          float minimum_speed = 0.0;
          if (id(undermount_thermostat).action == CLIMATE_ACTION_COOLING) {
            minimum_speed = id(cooling_min_power).state;  // 40%
            ESP_LOGD("PID", "Cooling mode - minimum: %.0f%%", minimum_speed);
          } else if (id(undermount_thermostat).mode == CLIMATE_MODE_FAN_ONLY) {
            minimum_speed = 20.0;  // 20%
            ESP_LOGD("PID", "Fan-only mode - minimum: 20%%");
          }
          
          // Convert to fan speed percentage and apply minimum
          int fan_speed = round(output * 97);  // Max 97% as per requirements
          fan_speed = fmax(minimum_speed, fmin(97, fan_speed));
          
          ESP_LOGI("PID", "FINAL: Error: %.2f°C, Output: %.2f, Fan: %d%%", error, output, fan_speed);
          
          // Apply via ramp controller
          id(target_blower_speed) = fan_speed;
          id(ramp_blower) = true;
          ESP_LOGD("PID", "Set target speed: %d%%, enabled ramping", fan_speed);

  - id: update_compressor_control
    then:
      - lambda: |-
          // Only manage high-speed when cooling and auto high-speed is enabled
          if (id(undermount_thermostat).action != CLIMATE_ACTION_COOLING || 
              !id(enable_high_speed).state ||
              id(high_speed_test).state) {  // Don't interfere with manual test
            return;
          }
          
          uint32_t now = millis();
          float current_speed = id(blower_speed_called).state;
          
          // Track threshold status
          bool threshold_currently_met = (current_speed >= 75.0);
          
          // Handle threshold met transition
          if (threshold_currently_met && !id(high_speed_threshold_met)) {
            id(high_speed_threshold_met) = true;
            id(high_speed_threshold_met_time) = now;
            ESP_LOGD("HighSpeed", "Threshold met at %.0f%% - starting timer", current_speed);
          }
          
          // Handle threshold unmet transition  
          if (!threshold_currently_met && id(high_speed_threshold_met)) {
            id(high_speed_threshold_met) = false;
            id(high_speed_threshold_unmet_time) = now;
            ESP_LOGD("HighSpeed", "Threshold unmet at %.0f%% - starting timer", current_speed);
          }
          
          // Check for activation (threshold met for 2 minutes)
          if (id(high_speed_threshold_met) && !id(high_speed_active)) {
            uint32_t time_met = now - id(high_speed_threshold_met_time);
            if (time_met >= 120000) {  // 2 minutes
              id(high_speed_active) = true;
              id(compressor_speed_high).turn_on();
              ESP_LOGI("HighSpeed", "Activated after 2 minutes at high demand");
            }
          }
          
          // Check for deactivation (threshold unmet for 2 minutes)
          if (!id(high_speed_threshold_met) && id(high_speed_active)) {
            uint32_t time_unmet = now - id(high_speed_threshold_unmet_time);
            if (time_unmet >= 120000) {  // 2 minutes
              id(high_speed_active) = false;
              id(compressor_speed_high).turn_off();
              ESP_LOGI("HighSpeed", "Deactivated after 2 minutes below threshold");
            }
          }

  - id: status_light_update
    then:
      - if:
          condition:
            lambda: 'return id(undermount_thermostat).mode == CLIMATE_MODE_OFF;'
          then:
            - light.turn_on:
                id: statusledlight
                red: 50%
                green: 35%
                blue: 0%
                brightness: 30%
                effect: "None"
      - if:
          condition:
            lambda: 'return id(undermount_thermostat).action == CLIMATE_ACTION_IDLE;'
          then:
            - light.turn_on: 
                id: statusledlight
                red: 0%
                green: 0%
                blue: 100%
                brightness: 20%
                effect: "None"
      - if:
          condition:
            lambda: 'return id(undermount_thermostat).action == CLIMATE_ACTION_COOLING;'
          then:
            - if:
                condition:
                  switch.is_on: compressor_speed_high
                then:
                  - light.turn_on: 
                      id: statusledlight
                      red: 0%
                      green: 0%
                      blue: 100%
                      brightness: 40%
                      effect: "Pulse Fast"
                else:
                  - light.turn_on: 
                      id: statusledlight
                      red: 0%
                      green: 0%
                      blue: 100%
                      brightness: 40%
                      effect: "Pulse"
      - if:
          condition:
            lambda: 'return id(undermount_thermostat).mode == CLIMATE_MODE_FAN_ONLY;'
          then:
            - light.turn_on: 
                id: statusledlight
                red: 0%
                green: 100%
                blue: 100%
                brightness: 40%
                effect: "Pulse"

interval:
  # Improved Blower ramp controller
  - interval: 200ms
    id: blower_ramp_control
    then:
      - lambda: |-
          if (!id(ramp_blower)) {
            return;
          }
          
          ESP_LOGD("Ramp", "=== RAMP ACTIVE ===");
          ESP_LOGD("Ramp", "Target: %.0f%%, Current: %.0f%%, Fan State: %s", 
                   id(target_blower_speed), id(current_blower_speed),
                   id(blower_fan).state ? "ON" : "OFF");
          
          // Ensure fan is on if target > 0
          if (id(target_blower_speed) > 0 && !id(blower_fan).state) {
            auto call = id(blower_fan).make_call();
            call.set_state(true);
            call.set_speed(1);  // Start at 1%
            call.perform();
            ESP_LOGI("Ramp", "Fan was OFF - turning ON");
            return;  // Wait for next cycle
          }
          
          const float transition_time = 10.0;  // 10 seconds 0-100%
          const float interval_time = 0.200;   // 200ms
          const float step_size = 100.0 / (transition_time / interval_time);  // 2% per step
          
          float diff = id(target_blower_speed) - id(current_blower_speed);
          ESP_LOGD("Ramp", "Difference: %.2f%%, Step size: %.2f%%", diff, step_size);
          
          if (fabs(diff) <= step_size) {
            // Reached target
            id(current_blower_speed) = id(target_blower_speed);
            id(ramp_blower) = false;
            
            ESP_LOGI("Ramp", "TARGET REACHED: %.0f%%", id(current_blower_speed));
            
            if (id(target_blower_speed) <= 0) {
              auto call = id(blower_fan).make_call();
              call.set_state(false);
              call.perform();
              ESP_LOGI("Ramp", "Fan turned OFF");
            } else {
              // Convert percentage to speed value (1-100)
              int speed_value = round(id(current_blower_speed));
              speed_value = fmax(1, fmin(100, speed_value));
              
              ESP_LOGW("RampDebug", "CALLING FAN SET_SPEED: %d for %.0f%%", speed_value, id(current_blower_speed));
              
              auto call = id(blower_fan).make_call();
              call.set_speed(speed_value);
              call.perform();
              ESP_LOGI("Ramp", "Fan set to speed %d (%.0f%%)", speed_value, id(current_blower_speed));
            }
          } else {
            // Continue ramping
            float step = (diff > 0) ? step_size : -step_size;
            id(current_blower_speed) += step;
            id(current_blower_speed) = fmax(0, fmin(100, id(current_blower_speed)));
            
            ESP_LOGD("Ramp", "Ramping to %.0f%%", id(current_blower_speed));
            
            // Convert percentage to speed value (1-100)
            int speed_value = round(id(current_blower_speed));
            speed_value = fmax(1, fmin(100, speed_value));
            
            ESP_LOGD("RampDebug", "CALLING FAN SET_SPEED: %d for %.0f%%", speed_value, id(current_blower_speed));
            
            auto call = id(blower_fan).make_call();
            call.set_speed(speed_value);
            call.perform();
            ESP_LOGD("Ramp", "Set fan to speed %d (%.0f%%)", speed_value, id(current_blower_speed));
          }

  # Protection timer management with override awareness
  - interval: 5s
    id: protection_timer_check
    then:
      - lambda: |-
          uint32_t now = millis();
          
          // Check for pending cooling request when restart protection expires
          if (!id(compressor_running) && id(pending_state_change) == 3) {
            uint32_t time_since_stop = now - id(compressor_stop_time);
            if (time_since_stop >= 120000) {  // 2 minutes elapsed
              ESP_LOGI("Protection", "Restart protection expired - executing pending cooling request");
              id(pending_state_change) = 0;
              
              // Start compressor
              id(compressor_power).turn_on();
              id(compressor_running) = true;
              id(compressor_start_time) = now;
              ESP_LOGI("Compressor", "Started from pending request - protection active for 2 minutes");
            }
          }
          
          // Check if short cycle protection has expired and we have pending state changes
          if (id(compressor_running)) {
            uint32_t time_since_start = now - id(compressor_start_time);
            if (time_since_start >= 120000) {  // 2 minutes elapsed
              // Short cycle protection expired
              if (id(pending_state_change) == 1) {
                // Execute pending idle
                ESP_LOGI("Protection", "Executing delayed idle transition");
                id(pending_state_change) = 0;
                id(execute_idle_transition).execute();
              } else if (id(pending_state_change) == 2) {
                // Execute pending off
                ESP_LOGI("Protection", "Executing delayed off transition");
                id(pending_state_change) = 0;
                id(execute_off_transition).execute();
              }
            }
          }

  # Periodic PID execution only when needed
  - interval: 10s
    id: pid_execution_timer
    then:
      - lambda: |-
          // Only run PID in auto fan mode AND when system needs fan control
          if (id(undermount_thermostat).fan_mode == CLIMATE_FAN_AUTO &&
              id(undermount_thermostat).mode != CLIMATE_MODE_OFF &&
              (id(undermount_thermostat).mode == CLIMATE_MODE_FAN_ONLY || 
               id(undermount_thermostat).action == CLIMATE_ACTION_COOLING)) {
            ESP_LOGD("PID_Timer", "Triggering periodic PID execution");
            id(climate_fan_auto_pid).execute();
          } else {
            ESP_LOGD("PID_Timer", "PID not applicable - Mode: %d, Action: %d, Fan Mode: %d",
                     id(undermount_thermostat).mode, id(undermount_thermostat).action, 
                     id(undermount_thermostat).fan_mode);
          }

  # Safety monitoring
  - interval: 30s
    id: safety_monitor
    then:
      - lambda: |-
          // Check for dangerous condition: compressor running without blower
          if (id(compressor_power).state && !id(blower_fan).state) {
            ESP_LOGW("SAFETY", "CRITICAL: Compressor running without blower!");
            
            // Emergency blower start
            float min_speed = id(cooling_min_power).state;
            id(target_blower_speed) = min_speed;
            id(current_blower_speed) = 1;  // Start from 1% not 0
            id(ramp_blower) = true;
            
            // Start fan at minimum speed
            auto call = id(blower_fan).make_call();
            call.set_state(true);
            call.set_speed(1);  // Start at 1%
            call.perform();
            
            ESP_LOGW("SAFETY", "Emergency blower restart initiated at %.0f%%", min_speed);
          }
          
          // Debug current state
          ESP_LOGD("Debug", "=== SYSTEM STATE ===");
          ESP_LOGD("Debug", "Mode: %d, Action: %d, Fan Mode: %d", 
                   id(undermount_thermostat).mode,
                   id(undermount_thermostat).action,
                   id(undermount_thermostat).fan_mode);
          ESP_LOGD("Debug", "Compressor: %s, Fan: %s", 
                   id(compressor_power).state ? "ON" : "OFF",
                   id(blower_fan).state ? "ON" : "OFF");
          ESP_LOGD("Debug", "Target Speed: %.0f%%, Current Speed: %.0f%%, Ramping: %s",
                   id(target_blower_speed), id(current_blower_speed),
                   id(ramp_blower) ? "YES" : "NO");
          ESP_LOGD("Debug", "Compressor Running: %s, Protection Active: %s, Pending: %d",
                   id(compressor_running) ? "YES" : "NO",
                   id(compressor_protection_active).state ? "YES" : "NO",
                   id(pending_state_change));